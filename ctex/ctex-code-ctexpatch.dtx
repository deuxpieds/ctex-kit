% \iffalse meta-comment
%
% Copyright (C) 2003--2020
% CTEX.ORG and any individual authors listed elsewhere in this file.
% --------------------------------------------------------------------------
%
% This work may be distributed and/or modified under the
% conditions of the LaTeX Project Public License, either
% version 1.3c of this license or (at your option) any later
% version. This version of this license is in
%    http://www.latex-project.org/lppl/lppl-1-3c.txt
% and the latest version of this license is in
%    http://www.latex-project.org/lppl.txt
% and version 1.3 or later is part of all distributions of
% LaTeX version 2005/12/01 or later.
%
% This work has the LPPL maintenance status `maintained'.
%
% The Current Maintainers of this work are Leo Liu, Qing Lee and Liam Huang.
%
% --------------------------------------------------------------------------
%
% \fi
%

% \section{\pkg{ctexpatch} 宏包}
%
%    \begin{macrocode}
%<*ctexpatch>
%    \end{macrocode}
%
%    \begin{macrocode}
\cs_if_exist:NF \str_new:N { \RequirePackage { l3str } }
%    \end{macrocode}
%
% \begin{macro}[int]{\ctex_patch_cmd_once:NnnnTF}
% 只进行第一次匹配进行替换。参数 |#2| 是宏重建时的 \tn{catcode} 设置。
%    \begin{macrocode}
\cs_new_protected:Npn \ctex_patch_cmd_once:NnnnTF #1#2
  {
    \ctex_patch_boot:NNnnTF \@@_patch_cmd:Nnnnnw #1
      { once } {#2} { \use_i:nn } { \use_ii:nn }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{\ctex_patch_cmd_all:NnnnTF}
% 替换所有匹配到的文本。
%    \begin{macrocode}
\cs_new_protected:Npn \ctex_patch_cmd_all:NnnnTF #1#2
  {
    \ctex_patch_boot:NNnnTF \@@_patch_cmd:Nnnnnw #1
      { all } {#2} { \use_i:nn } { \use_ii:nn }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{\ctex_patch_cmd:Nnn}
% 快捷方式，在补丁的时候关闭 \LaTeXiii{} 语法和设置 |@| 为字母类，补丁失败时给出警告。
%    \begin{macrocode}
\cs_new_protected:Npn \ctex_patch_cmd:Nnn #1
  {
    \ctex_patch_boot:NNnnTF \@@_patch_cmd:Nnnnnw #1
      { once }
      {
        \ExplSyntaxOff
        \char_set_catcode_letter:n { 64 }
      }
      { }
      { \ctex_patch_failure:N #1 }
  }
\cs_new_protected:Npn \ctex_patch_failure:N #1
  { \msg_warning:nnx { ctex } { patch-failure } { \token_to_str:N #1 } }
\msg_new:nnn { ctex } { patch-failure }
  { Oops!~Command~`#1'~is~NOT~patchable.\\ }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{\ctex_preto_cmd:NnnTF}
% 在宏的原本定义前面增加钩子。
%    \begin{macrocode}
\cs_new_protected:Npn \ctex_preto_cmd:NnnTF #1#2
  {
    \ctex_patch_boot:NNnnTF \@@_hookto_cmd:Nnnnw #1
      { left } {#2} { \use_i:nn } { \use_ii:nn }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{\ctex_appto_cmd:NnnTF}
% 在宏的原本定义后面追加钩子。
%    \begin{macrocode}
\cs_new_protected:Npn \ctex_appto_cmd:NnnTF #1#2
  {
    \ctex_patch_boot:NNnnTF \@@_hookto_cmd:Nnnnw #1
      { right } {#2} { \use_i:nn } { \use_ii:nn }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{\ctex_patch_boot:NNnnTF}
% 参数记号 |#| 作为宏的参数被读入时，总是会双写，会影响随后的字符串替换。需要先
% 将它转换为普通符号。
%    \begin{macrocode}
\cs_new_protected:Npn \ctex_patch_boot:NNnnTF #1#2#3#4#5#6
  {
    \tl_set:Nn \@@_patch_true:w {#5}
    \tl_set:Nn \@@_patch_false:w {#6}
    \group_begin:
      \char_set_catcode_other:n { 35 }
      \ctex_parse_name:NN #1 #2 {#3} {#4}
  }
\tl_new:N \@@_patch_true:w
\tl_new:N \@@_patch_false:w
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{\ctex_parse_name:NN}
% 用 \tn{DeclareRobustCommand} 定义的宏或者由 \tn{newcommand} 或 \tn{newrobustcmd}
% 定义的带一个可选参数的宏第一次展开的结果都不是其实际定义，实际定义被保存在另外的
% 宏中。由这些命令定义的宏的第一次展开结果可以有下面的形式（细节可查阅 \pkg{xpatch}
% 的文档）：
% \begin{verbatim}[numbers=left,gobble=4]
%   \protect␣\xaa␣␣                    % \DeclareRobustCommand\xaa[1]{...}
%   \protect␣\xab␣␣                    % \DeclareRobustCommand\xab[1][]{...}
%   \@protected@testopt␣\xac␣\\xac␣{}  % \newcommand\xac[1][]{...}
%   \@testopt␣\\xad␣{}                 % \newrobustcmd\xad[1][]{...}
%   \x@protect␣\1\protect␣\1␣␣         % \DeclareRobustCommand\1[1]{...}
%   \x@protect␣\2\protect␣\2␣␣         % \DeclareRobustCommand\2[1][]{...}
%   \@protected@testopt␣\3\\3␣{}       % \newcommand\3[1][]{...}
%   \@testopt␣\\4␣{}                   % \newrobustcmd\4[1][]{...}
% \end{verbatim}
% \pkg{ctexpatch} 的主要原理是先对宏的 \tn{meaning} 作字符串替换，然后再用
% \tn{scantokens} 来重建它。我们希望对宏的实际定义打补丁，为此需要先得到
% 对应的名字。\pkg{letltxmacro}、\pkg{show2e} 和 \pkg{xpatch} 宏包中都有
% 类似的工作。
%    \begin{macrocode}
\cs_new_protected:Npn \ctex_parse_name:NN #1#2
  { \ctex_parse_name:NNx #1#2 { \cs_to_str:N #2 } }
\group_begin:
\cs_set_protected:Npn \@@_tmp:w #1#2#3
  {
    \cs_new_protected:Npn \ctex_parse_name:NNn ##1##2##3
      {
        \bool_lazy_or:nnTF
          { \cs_if_exist_p:c { ##3 ~ } }
          { \cs_if_exist_p:c { #1##3 } }
          {
            \group_begin:
            \use:x
              {
                \group_end:
                \@@_parse_name:nNNNnN
                  { \cs_replacement_spec:N ##2 }
                  \exp_not:N ##2
                  \exp_not:c { ##3 ~ }
                  \exp_not:c { #1##3 }
              } {##3} ##1
          }
          { ##1##2 }
      }
    \cs_new_protected:Npn \@@_parse_name:nNNNnN ##1##2##3##4##5##6
      {
        \exp_args:Nc ##6
          {
            \str_case:nnTF {##1}
              {
                { \protect ##3 } { }
                { \x@protect ##2 \protect ##3 } { }
              }
              {
                \str_if_eq:eeTF
                  { \exp_not:n { #1@protected@ ##3 #1##3 } }
                  {
                    \exp_last_unbraced:Nf \@@_parse_name:w
                      \cs_replacement_spec:N ##3 #3 ~ #2 \q_stop
                  }
                  { #1##5 ~ } { ##5 ~ }
              }
              {
                \str_case:onTF { \@@_parse_name:w ##1 #3 ~ #2 \q_stop }
                  {
                    { #1@protected@ ##2 ##4 } { }
                    { #1@ ##4 } { }
                  }
                  { #1##5 } {##5}
              }
          }
      }
    \cs_new:Npn \@@_parse_name:w ##1 #3 ~ ##2 #2 ##3 \q_stop { ##1##2 }
  }
\use:x
  {
    \@@_tmp:w
      { \c_backslash_str }
      { \c_left_brace_str }
      { \tl_to_str:n { testopt } }
  }
\group_end:
\cs_generate_variant:Nn \ctex_parse_name:NNn { NNx }
%    \end{macrocode}
% \end{macro}
%
% \begin{variable}{\l_@@_prefix_str,\l_@@_parameter_str,\l_@@_replacement_str}
% 分别保存宏的 \tn{meaning} 中的前缀、参数文本和替换文本。
%    \begin{macrocode}
\str_new:N \l_@@_prefix_str
\str_new:N \l_@@_parameter_str
\str_new:N \l_@@_replacement_str
%    \end{macrocode}
% \end{variable}
%
% \begin{macro}[int]{\ctex_get_macro_meaning:NTF}
% \begin{macro}{\@@_get_macro_meaning:w}
% 解构待补丁宏的 \tn{meaning}。若命令不是宏，则走向 |false| 分支。
%    \begin{macrocode}
\group_begin:
  \cs_set_protected:Npn \@@_tmp:w #1
    {
      \prg_new_protected_conditional:Npnn
        \ctex_get_macro_meaning:N ##1 { TF }
        {
          \exp_after:wN \@@_get_macro_meaning:w
            \token_to_meaning:N ##1 \q_mark #1 -> \q_mark \q_stop
        }
      \cs_new_protected:Npn \@@_get_macro_meaning:w
          ##1 #1 ##2 -> ##3 \q_mark ##4 \q_stop
        {
          \tl_if_empty:nTF { ##4 }
            { \prg_return_false: }
            {
              \str_set:Nn \l_@@_prefix_str      { ##1 }
              \str_set:Nn \l_@@_parameter_str   { ##2 }
              \str_set:Nn \l_@@_replacement_str { ##3 }
              \prg_return_true:
            }
        }
    }
  \exp_args:No \@@_tmp:w { \tl_to_str:n { macro: } }
\group_end:
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[int]{\ctex_if_rescanable:NnTF}
% 检查宏是否可以重建。
%    \begin{macrocode}
\cs_new_protected:Npn \ctex_if_rescanable:NnTF #1#2#3#4
  {
    \ctex_get_macro_meaning:NTF #1
      {
        \@@_patch_rebuild:Nn \@@_rebuild_cmd:w {#2}
        \cs_if_eq:NNTF #1 \@@_rebuild_cmd:w {#3} {#4}
      }
      {#4}
  }
\cs_new_eq:NN \@@_rebuild_cmd:w \prg_do_nothing:
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_patch_rebuild:Nn}
% 使用 \cs{tl_rescan:nn} 来重新记号化 \tn{meaning} 字符串。
%    \begin{macrocode}
\cs_new_protected:Npn \@@_patch_rebuild:Nn #1#2
  {
    \@@_patch_rescan:NNn \l_@@_prefix_tl      \l_@@_prefix_str      {#2}
    \@@_patch_rescan:NNn \l_@@_parameter_tl   \l_@@_parameter_str   {#2}
    \@@_patch_rescan:NNn \l_@@_replacement_tl \l_@@_replacement_str {#2}
    \use:x
      {
        \exp_not:o { \l_@@_prefix_tl } \tex_def:D \exp_not:N #1
          \exp_not:o { \l_@@_parameter_tl }
            { \exp_not:o { \l_@@_replacement_tl } }
      }
  }
\cs_new_protected:Npn \@@_patch_rescan:NNn #1#2#3
  {
    \str_if_empty:NTF #2
      { \tl_clear:N #1 }
      { \tl_set_rescan:Nno #1 {#3} {#2} }
  }
\tl_new:N \l_@@_prefix_tl
\tl_new:N \l_@@_parameter_tl
\tl_new:N \l_@@_replacement_tl
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_patch_cmd:Nnnnnw}
% 对宏的替换文本进行字符串替换，然后重建。
%    \begin{macrocode}
\cs_new_protected:Npn \@@_patch_cmd:Nnnnnw #1#2#3#4#5
  {
    \group_end:
    \ctex_if_rescanable:NnTF #1 {#3}
      {
        \use:x
          {
            \@@_patch_replace:nnnTF {#2}
              { \tl_to_str:n {#4} }
              { \tl_to_str:n {#5} }
          }
          {
            \@@_patch_rebuild:Nn #1 {#3}
            \@@_patch_true:w
          }
          { \@@_patch_false:w }
      }
      { \@@_patch_false:w }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_patch_replace:nnnTF}
% 替换前先检查原文本是否存在。
%    \begin{macrocode}
\cs_new_protected:Npn \@@_patch_replace:nnnTF #1#2#3#4
  {
    \tl_if_in:NnTF \l_@@_replacement_str {#2}
      { \use:c { tl_replace_ #1 :Nnn } \l_@@_replacement_str {#2} {#3} #4 }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_hookto_cmd:Nnnnw}
% 在宏的前/后附加钩子。
%    \begin{macrocode}
\cs_new_protected:Npn \@@_hookto_cmd:Nnnnw #1#2#3#4
  {
    \group_end:
    \ctex_get_macro_meaning:NTF #1
      {
        \str_if_empty:NTF \l_@@_parameter_str
          { \@@_hookto_cmd_parameterless:Nnnnw }
          { \@@_hookto_cmd_parameter:Nnnnw }
          #1 {#2} {#3} {#4}
      }
      { \@@_patch_false:w }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_hookto_cmd_parameterless:Nnnnw}
% 如果宏没有参数，可以直接进行附加操作。注意保持宏的前缀。
%    \begin{macrocode}
\cs_new_protected:Npn \@@_hookto_cmd_parameterless:Nnnnw #1#2#3#4
  {
    \str_if_empty:NF \l_@@_prefix_str
      { \tl_rescan:no {#3} { \l_@@_prefix_str } }
    \tex_edef:D #1
      {
        \use:c { @@_ #2 _hook_aux:nn }
          { \exp_not:o {#1} }
          { \exp_not:n {#4} }
      }
    \@@_patch_true:w
  }
\cs_generate_variant:Nn \tl_rescan:nn { no }
\cs_new:Npn \@@_left_hook_aux:nn #1#2 { #2#1 }
\cs_new_eq:NN \@@_right_hook_aux:nn \use:nn
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_hookto_cmd_parameter:Nnnnw}
% 如果宏有参数，需要在字符串中进行附加，然后再重建。
%    \begin{macrocode}
\cs_new_protected:Npn \@@_hookto_cmd_parameter:Nnnnw #1#2#3#4
  {
    \@@_patch_rebuild:Nn \@@_rebuild_cmd:w {#3}
    \cs_if_eq:NNTF #1 \@@_rebuild_cmd:w
      {
        \use:c { str_put_ #2 :Nn } \l_@@_replacement_str {#4}
        \@@_patch_rebuild:Nn #1 {#3}
        \@@_patch_true:w
      }
      { \@@_patch_false:w }
  }
%    \end{macrocode}
% \end{macro}
%
%    \begin{macrocode}
%</ctexpatch>
%    \end{macrocode}
